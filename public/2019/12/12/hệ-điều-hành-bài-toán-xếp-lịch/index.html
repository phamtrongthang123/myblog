<!DOCTYPE html>
<html lang="vi-VN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Hệ điều hành: Bài toán xếp lịch | Trong-Thang Pham&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="https://github.com/phamtrongthang123">GitHub</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Hệ điều hành: Bài toán xếp lịch</span></h1>
<h2 class="author">Trong-Thang Pham</h2>
<h2 class="date">2019/12/12</h2>
</div>

<main>


<div id="TOC">
<ul>
<li><a href="#section">6.1</a></li>
<li><a href="#section-1">6.2</a></li>
<li><a href="#section-2">6.3</a></li>
<li><a href="#section-3">6.4</a></li>
<li><a href="#section-4">6.5</a></li>
<li><a href="#section-5">6.6</a></li>
<li><a href="#section-6">6.30</a></li>
<li><a href="#section-7">6.31</a></li>
</ul>
</div>

<div id="section" class="section level3">
<h3>6.1</h3>
<p>A CPU-scheduling algorithm determines an order for the execution
of its scheduled processes. Given n processes to be scheduled on one
processor, how many different schedules are possible? Give a formula
in terms of n.</p>
<div id="answer" class="section level4">
<h4>Answer:</h4>
<blockquote>
<p><span class="math inline">\(n!\)</span> ._.</p>
</blockquote>
</div>
</div>
<div id="section-1" class="section level3">
<h3>6.2</h3>
<p>Explain the difference between preemptive and nonpreemptive scheduling.</p>
<div id="answer-1" class="section level4">
<h4>Answer:</h4>
<blockquote>
<p>Under nonpreemptive scheduling, once the CPU has been
allocated to a process, the process keeps the CPU until it releases the CPU either
by terminating or by switching to the waiting state</p>
<p>Nhắc lại 4 trạng thái CPU scheduling nắm quyền được:</p>
<ul>
<li><ol style="list-style-type: decimal">
<li>When a process switches from the running state to the waiting state (for
example, as the result of an I/O request or an invocation of wait() for
the termination of a child process)</li>
</ol></li>
<li><ol start="2" style="list-style-type: decimal">
<li>When a process switches from the running state to the ready state (for
example, when an interrupt occurs)</li>
</ol></li>
<li><ol start="3" style="list-style-type: decimal">
<li>When a process switches from the waiting state to the ready state (for
example, at completion of I/O)</li>
</ol></li>
<li><ol start="4" style="list-style-type: decimal">
<li>When a process terminates</li>
</ol></li>
</ul>
<p>Nonpreemtive là 1,4. 2,3 là preemptive.</p>
</blockquote>
</div>
<div id="từ-sol" class="section level4">
<h4>Từ sol:</h4>
<blockquote>
<p>Preemptive scheduling allows a process to be interrupted in the midst of
its execution, taking the CPU away and allocating it to another process.
Nonpreemptive scheduling ensures that a process relinquishes control
of the CPU only when it finishes with its current CPU burst.</p>
</blockquote>
</div>
</div>
<div id="section-2" class="section level3">
<h3>6.3</h3>
<p>Suppose that the following processes arrive for execution at the times
indicated. Each process will run for the amount of time listed. In
answering the questions, use nonpreemptive scheduling, and base all
decisions on the information you have at the time the decision must be
made.</p>
<table>
<thead>
<tr class="header">
<th align="left">Process</th>
<th align="left">Arrival Time</th>
<th align="left">Burst Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">P1</td>
<td align="left">0.0</td>
<td align="left">8</td>
</tr>
<tr class="even">
<td align="left">P2</td>
<td align="left">0.4</td>
<td align="left">4</td>
</tr>
<tr class="odd">
<td align="left">P3</td>
<td align="left">1.0</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<ol style="list-style-type: lower-alpha">
<li><p>What is the average turnaround time for these processes with the
FCFS scheduling algorithm?</p></li>
<li><p>What is the average turnaround time for these processes with the
SJF scheduling algorithm?</p></li>
<li><p>The SJF algorithm is supposed to improve performance, but notice
that we chose to run process P1 at time 0 because we did not know
that two shorter processes would arrive soon. Compute what the
average turnaround time will be if the CPU is left idle for the first
1 unit and then SJF scheduling is used. Remember that processes
P1 and P2 are waiting during this idle time, so their waiting time
may increase. This algorithm could be called future-knowledge
scheduling.</p></li>
</ol>
<div id="answer-2" class="section level4">
<h4>Answer:</h4>
<blockquote>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li>theo thứ tự là 1,2,3 =&gt; (0+8+12) / 3 = 6.67</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>nonpreempt, nhưng theo thứ tự thì là 1 3 2 (có đảo vì nhảy theo 1 unit, nên nhảy xong thì 3 pri cao hơn 2) là 5.67</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li>yeah, tại t=0 thì không biết. theo đề thì ý là chờ 1 unit, aka là Arrival time giờ mọi đứa đều ngang nhau.
Thứ tự mới sẽ là 3,2,1 với time chờ mới +1 =&gt; (1+2+6)/3=3 , có +1 vì thằng đầu cũng chờ 1s</li>
</ol></li>
</ul>
</blockquote>
</div>
<div id="theo-sol" class="section level4">
<h4>Theo sol:</h4>
<blockquote>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li>10.53</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>9.53</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li>6.86</li>
</ol></li>
</ul>
<p>Ơ thôi chết nhớ nhầm waiting time rồi, <span class="math display">\[turnaround\ \ time = finish - arrival\]</span>, vậy không bỏ cái cuối aka.
vậy câu a là <span class="math display">\[8-0 + 12 - 0.4 + 13-1)/3 = 10.53\]</span>, đúng rồi :’(
b là <span class="math display">\[(8+9-1+13-0.4)/3 = 9.53\]</span> và c là <span class="math display">\[(2-1 + 6-0.4+14-0)/3 = 6.86\]</span></p>
</blockquote>
</div>
</div>
<div id="section-3" class="section level3">
<h3>6.4</h3>
<p>What advantage is there in having different time-quantum sizes at
different levels of a multilevel queueing system?</p>
<div id="answer-3" class="section level4">
<h4>Answer:</h4>
<blockquote>
<p>Cái này đăng không nói tới feedback nên thật sự không hình dung nổi lợi ích chỗ nào .-.</p>
</blockquote>
</div>
<div id="sol" class="section level4">
<h4>Sol:</h4>
<blockquote>
<p>Processes that need more frequent servicing, for instance, interactive
processes such as editors, can be in a queue with a small time quantum.
Processes with no need for frequent servicing can be in a queue with
a larger quantum, requiring fewer context switches to complete the
processing, and thus making more efficient use of the computer.</p>
</blockquote>
</div>
</div>
<div id="section-4" class="section level3">
<h3>6.5</h3>
<p>Many CPU-scheduling algorithms are parameterized. For example, the
RR algorithm requires a parameter to indicate the time slice. Multilevel
feedback queues require parameters to define the number of queues, the
scheduling algorithm for each queue, the criteria used to move processes
between queues, and so on.</p>
<p>These algorithms are thus really sets of algorithms (for example, the
set of RR algorithms for all time slices, and so on). One set of algorithms
may include another (for example, the FCFS algorithm is the RR algorithm
with an infinite time quantum). What (if any) relation holds between the
following pairs of algorithm sets?</p>
<ol style="list-style-type: lower-alpha">
<li><p>Priority and SJF</p></li>
<li><p>Multilevel feedback queues and FCFS</p></li>
<li><p>Priority and FCFS</p></li>
<li><p>RR and SJF</p></li>
</ol>
<div id="answer-4" class="section level4">
<h4>Answer:</h4>
<blockquote>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li>SJF là trường hợp prio inverse thời gian CPU burst của Pri</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>cho nó là 1 level chạy fcfs là giống nhỉ ._.</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li>FCFS là trường hợp prio đều hết cho mọi proc của Pri</li>
</ol></li>
<li><ol start="4" style="list-style-type: lower-alpha">
<li>Ủa có không nhỉ, SJF là FCFS khi SJF có arrival lần lượt, nên nếu lần lượt thì RR giống SJF với inf quantum time.</li>
</ol></li>
</ul>
</blockquote>
</div>
<div id="sol-1" class="section level4">
<h4>Sol:</h4>
<blockquote>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li>The shortest job has the highest priority. &lt;= yeah</li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li>The lowest level of MLFQ is FCFS. &lt;= yeah</li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li>FCFS gives the highest priority to the job having been in existence
the longest. &lt;= nani. à do mình đọc lướt sách nên không để ý, sách ghi là nếu pri eual sẽ chạy như fcfs, nhưng mà … mình cũng đâu sai nhỉ. nvm sol nghe dễ chấp nhận hơn.</li>
</ol></li>
<li><ol start="4" style="list-style-type: lower-alpha">
<li>None. &lt;= yeah, mình thì đem đi so sánh với trung gian là fcfs =]]]] mà mình cũng ghi bậy thêm arrival. nghĩ nhiều rồi.</li>
</ol></li>
</ul>
</blockquote>
</div>
</div>
<div id="section-5" class="section level3">
<h3>6.6</h3>
<p>Suppose that a scheduling algorithm (at the level of short-term CPU
scheduling) favors those processes that have used the least processor
time in the recent past. Why will this algorithm favor I/O-bound
programs and yet not permanently starve CPU-bound programs?</p>
<div id="answer-5" class="section level4">
<h4>Answer:</h4>
<blockquote>
<p>._. không biết. Chắc là io bound thì dùng ít cpu nên được favor. còn vế sau thì không nghĩ ra.</p>
</blockquote>
</div>
<div id="sol-biết-cũng-tốt" class="section level4">
<h4>Sol (biết cũng tốt):</h4>
<blockquote>
<p>It will favor the I/O-bound programs because of the relatively short CPU
burst request by them; however, the CPU-bound programs will not starve
because the I/O-bound programs will relinquish the CPU relatively often
to do their I/O.</p>
</blockquote>
</div>
</div>
<div id="section-6" class="section level3">
<h3>6.30</h3>
<p>Under what circumstances is rate-monotonic scheduling inferior to
earliest-deadline-first scheduling in meeting the deadlines associated
with processes?</p>
<div id="answer-6" class="section level4">
<h4>Answer:</h4>
<blockquote>
<p>theo sách thì EDF optimal rồi. RMS thì max là n*(2^1/n - 1), còn EDF tới 100 được.
Theo ví dụ trong sách ráng nhớ là p1 = 50, t1 = 25, p2 = 80, t2 = 35, 25/50 + 35/80 = 0.94, RMS failed chỗ này</p>
</blockquote>
</div>
</div>
<div id="section-7" class="section level3">
<h3>6.31</h3>
<p>Consider two processes, P1 and P2, where p1 = 50, t1 = 25, p2 = 75, and
t2 = 30.</p>
<ol style="list-style-type: lower-alpha">
<li><p>Can these two processes be scheduled using rate-monotonic
scheduling? Illustrate your answer using a Gantt chart such as
the ones in Figure 6.16–Figure 6.19.</p></li>
<li><p>Illustrate the scheduling of these two processes using earliestdeadline-first (EDF) scheduling</p></li>
</ol>
<blockquote>
<ol style="list-style-type: lower-alpha">
<li>0.9 cpu util, có thể failed. Để vẽ nháp thử
<img src="/post/2019-12-12-hệ-điều-hành-bài-toán-xếp-lịch_files/79529938_568829707285709_2836350377408856064_n.jpg" /></li>
</ol>
<p>Failed thật</p>
<ol start="2" style="list-style-type: lower-alpha">
<li><img src="/post/2019-12-12-hệ-điều-hành-bài-toán-xếp-lịch_files/68697559_1272546706279638_2996055764193247232_n.jpg" /></li>
</ol>
</blockquote>
</div>

</main>

  <footer>
  <script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>
  
  </footer>
  </body>
</html>

